[toc]

## feature

1. 特性

   - 不支持多返回值: golang 支持
   - 函数可以作为参数, 变量, 返回值
   - 可以对任意对象扩展函数
   - 函数类可以嵌套函数: tailrec

2. 分类

   - 成员函数: 默认都是 public 的
   - 匿名函数(lambda&函数参数实现) | 具名函数(`var func: ()->Int = { 2}`)
   - 内联(inline)函数: 在编译时插入调用处(不是作为函数调用)
   - 中缀(infix)函数: 允许以一种更简洁的方式调用函数
   - 扩展函数
   - 高阶函数(lambda)
   - 泛型函数
   - 尾递归函数(tailrec):
     1. 递归调用是最后一个操作则可以修改成尾递归(可以解决栈帧的内存消耗问题-提高运行速度)
     2. 编译器会将其优化成循环实现
     3. 典型实现(在内部定义尾递归): 阶乘 | 斐波那契数

## 函数声明: 可以使用``对特殊字符处理

1. syntax: `fun NAME(VAR_NAME VAR_TYPE) : RETURN_TYPE`

   ```kotlin
   // 1.简单定义
   fun sum(a: Int, b: Int): Int {
      return a + b
   }

   // 2.等价于
   fun sum(a: Int, b: Int) = a + b
   fun sum(a: Int, b: Int): Int = a + b

   // 3.返回值类型为Unit可以省略
   fun printSum(a: Int, b: Int) = println("sum of $a and $b is ${a + b}")
   ```

2. 定义初始化函数变量

   ```kotlin
   // 3.直接赋值
   var funcVoid: () -> Unit = { println("hello") }
   var funcReturn: (x: String) -> String = { it }
   var funcArgs: (x: String, y: String) -> String = { x, y -> x + y }
   ```

3. 特殊函数名: 规避关键字等

   ```kotlin
   fun `123`() {}
   ```

## 函数变量

1. 函数变量 & 赋值(::)

   ```kotlin
   class _Func {
      // 定义函数
      fun sum(a: Int, b: Int): Int = a + b
      // 函数变量
      var funcType1: (Int, Int) -> Int = this::sum
      var funcType2: (Int, Int) -> Int = ::sum
   }

   fun main() {
       val func = _Func();

      // 1.定义函数类型
      var funcType: (Int, Int) -> Int

      // 2.函数赋值
      funcType = func::sum
      // funcType = { 实现(可以是labmbda) }

      // 函数调用1
      println("sum value: ${func.funcType1(1, 2)}")
      // 函数调用2
      println("sum value: ${funcType(1, 2)}")
   }
   ```

## 函数参数

1. 函数参数可以有默认值

   ```kotlin
   fun read(b: ByteArray, len: Int = b.size) {}
   ```

2. 具名函数参数

   ```kotlin
   fun sendMessage(to: String, message: String, priority: Int = 1) {}
   sendMessage(/*priority = 3,*/ message = "Hello", to = "John")
   ```

3. 函数可以做参数: 并且在最后一位可以变成方法体

   ```kotlin
   fun foo(
      bar: Int = 0,
      baz: Int = 1,
      qux: () -> Unit,
   ) { /*...*/ }

   foo(1) { println("hello") }     // Uses the default value baz = 1
   foo(qux = { println("hello") }) // Uses both default values bar = 0 and baz = 1
   foo { println("hello") }        // Uses both default values bar = 0 and baz = 1
   ```

## 函数返回值

1.  函数可以以函数作为返回值

    - 函数定义

      ```kotlin
      fun square(n: Int) : Int {
         return n * n
      }

      fun fun4(type: String): (Int) -> Int {
         when (type) {
            "square" -> return ::square
            else -> return { n ->
               n * n * n
            }
         }
      }

      fun fun5(type: String): (Int) -> Int {
         return if (type == "square") {
            ::square
         } else { n ->
            n * n * n
         }
      }
      ```

    - 函数调用

      ```kotlin
      fun main() {
         val func = _FuncReturn()
         val returnFunc = func.fun5("square")
         val square = returnFunc(4)

         println("square: $square")
      }
      ```

2.  kt 也不支持多返回值, 但是可以解构赋值: 很是遗憾(查一下为什么不支持)

    ```kotlin
    data class Person(var name: String, var age: Int, var gender: Char)
    fun fetchPersonDetails(): Person {xxx}
    fun main() {
       val (name, age, gender) = fetchPersonDetails()    // 解构声明
    }
    ```

    - Pair/Triple 类

      ```kotlin
      fun fetchPersonDetails(): Triple<String, Int, Char> {
         return Triple(name, age, gender)
      }

      fun main() {
         val (name, age, gender) = fetchPersonDetails()
      }
      ```

    - 返回一个数组

      ```kotlin
      fun fetchPersonDetails(): Array<Any> {
         return arrayOf(name, age, gender)
      }

      fun main() {
         val (name, age, gender) = fetchPersonDetails()
      }
      ```

    - **golang 支持多返回值**

      ```go
      func foo() (int, string) {
         return 42, "hello"
      }

      result1, result2 := foo()
      ```

## 函数类型

1. 成员函数: 定义在类或 object 的函数
2. 构造函数

   ```kotlin
   open class A { }

   class ConClass : A {
       constructor()
       constructor(s: String): this()
   }
   ```

3. infix

   ```kotlin
   class MyStringCollection {
      infix fun add(s: String) { /*...*/ }
      fun build() {
         this add "abc"   // Correct
         add("abc")       // Correct
         //add "abc"        // Incorrect: the receiver must be specified
      }
   }

   // 1.shl(2)  // 1 shl 2
   ```

4. 匿名函数 | 具名函数

   - 匿名函数

     ```kotlin
     val count = "Derry".count()

     "Derry".count() { x ->
        x == 'r'
     }
     "Derry".count { x ->
        x == 'r'
     }
     "Derry".count {
        it == 'r'
     }
     ```

   - 具名函数

     ```kotlin
     var func: ()->Int = { 2}
     ```

5. 尾递归函数(嵌套函数)

   ```kotlin
   // 阶乘
   fun factorial(n: Int): Int {
      if (n==0) return 1
      return n * factorial(n-1)
   }
   fun factorial(n: Int) : Int {
      tailrec fun factorialInner(n: Int, result: Int): Int {
         if (n == 1) return result
         return factorialInner(n-1, n*result)
      }

      return factorialInner(n, 1)
   }

   // 斐波那契
   fun fibonacci(n: Int): Int {
      if (n < 2) retrun n
      return fibonacci(n-1) + fibonacci(n-2)
   }
   fun fibonacci(n: Int): Int {
      tailrec fun fibonacciInner(n:Int, prev:Int, next:Int):Int {
         if (n < 1) retrun next
         return fibonacciInner(n-1, next, prev + next)
      }

      return fibonacciInner(n, 0, 1)
   }
   ```

## 函数扩展

1. kt 可以**灵活**的扩展函数: 不能写在 class 内

   ```kotlin
   // 对任意对象扩展了 ops 方法, 其返回值为 list
   fun Any.ops(): List<String> =  listOf("as")

   // 对String对象扩展了 todo 方法(报错)
   fun String.todo(): Unit {
      TODO()
   }

   // 对任意对象扩展了 logger() 对象: 且可以有泛型信息
   inline fun <reified R : Any> R.logger(): Logger = LoggerFactory.getLogger(
      this::class.java.name.substringBefore("\$Companion").substringBefore("\$\$EnhancerBy")
   )
   ```

2. golang 函数扩展

   ```go
   func (c *调用者) 函数名(参数) (返回值){
         函数体
   }
   ```

## build-in func
